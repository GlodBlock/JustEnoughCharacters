import com.google.gson.GsonBuilder
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.JsonPrimitive
import org.yaml.snakeyaml.Yaml

plugins {
    id 'java-library'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id "architectury-plugin" version "3.4-SNAPSHOT" apply false
    id 'dev.architectury.loom' version '1.1-SNAPSHOT' apply false
    id 'io.github.juuxel.loom-quiltflower' version '1.7.1' apply false
    id "io.github.p03w.machete" version "1.+" // automatic jar compressing on build
    id 'io.freefair.lombok' version '8.0.1' apply false
}

group = "me.towdium.jecharacters"
archivesBaseName = "jecharacters"
version = "${verspec}.${verbuild}"

allprojects {
    repositories {
        mavenCentral()
        mavenLocal()
        maven { url = "https://maven.architectury.dev/" }
        maven { url = "https://maven.minecraftforge.net/" }
        maven { url = "https://maven.blamejared.com/" }
        maven { url = "https://modmaven.dev" }
        maven { url = "https://maven.parchmentmc.org" }
        maven { url = "https://libraries.minecraft.net" }
        maven { url = "https://maven.terraformersmc.com/releases/" }
        maven { url = "https://repo.spongepowered.org/repository/maven-public/" }
        maven { url = "https://modmaven.dev" }
        maven {
            url = "https://cursemaven.com"
            content { includeGroup "curse.maven" }
        }
        maven { url = "https://www.jitpack.io" }
    }
}

configurations {
    shade
    compileOnly.extendsFrom shade
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

tasks.register('buildAll', Copy).configure { task ->
    subprojects.forEach { p ->
        if (ProjectType.getType(p) == ProjectType.ROOT) {
            task.dependsOn(":${p.name}:forge:build")
            task.dependsOn(":${p.name}:fabric:build")
        }
    }
}

tasks.register("cleanBuild", Delete).configure { task ->
    subprojects.forEach { p ->
        if (ProjectType.getType(p) == ProjectType.ROOT) {
            delete("${p.projectDir}/forge/build/libs")
            delete("${p.projectDir}/fabric/build/libs")
        }
    }
}

subprojects.each { p ->
    if (ProjectType.getType(p) == ProjectType.ROOT) {
        rootProject.tasks.register("build-${p.name}", Copy).configure { task ->
            task.dependsOn(":${p.name}:forge:build")
            task.dependsOn(":${p.name}:fabric:build")
        }
    }
}


enum ProjectType {
    MAIN,
    ROOT,
    COMMON,
    FORGE,
    FABRIC,

    static ProjectType getType(Project p) {
        try {
            if (p.name.contains("main"))
                return MAIN
            return valueOf(p.name.toUpperCase())
        } catch (Exception ignored) {
            return ROOT
        }
    }

    boolean notMain() {
        return this != MAIN
    }

    boolean notRoot() {
        return this != ROOT
    }

    boolean isRoot() {
        return this == ROOT
    }

    boolean notMainOrRoot() {
        return this != MAIN && this != ROOT
    }

    boolean isFabric() {
        return this == FABRIC
    }

    boolean isForge() {
        return this == FORGE
    }

    boolean isCommon() {
        return this == COMMON
    }

    boolean isImpl() {
        return this == FABRIC || this == FORGE
    }
}

subprojects { Project p ->
    apply plugin: 'java-library'
    apply plugin: 'com.github.johnrengelman.shadow'
    apply plugin: 'io.freefair.lombok'

    def type = ProjectType.getType(p)
    if (type.notMain()) {
        apply plugin: 'architectury-plugin'
        if (type.notRoot()) {
            apply plugin: 'io.github.juuxel.loom-quiltflower'
        }
    }

    java.toolchain.languageVersion = JavaLanguageVersion.of(17)
    java.withSourcesJar()

    p.archivesBaseName = rootProject.archivesBaseName
    p.group = rootProject.group
    p.version = "${verspec}.${verbuild}"

    if (type != ProjectType.MAIN) {
        def mc_version = type == ProjectType.ROOT ? p.mc_version : p.getParent().mc_version
        p.archivesBaseName += "-${mc_version}-${type.toString().toLowerCase()}"
    }

    p.processResources {
        // Exclude .cache directory which is generated by DataGen.
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        exclude '.cache'
    }

    p.afterEvaluate { Project pAfter ->

        if (type.notRoot()) {
            pAfter.dependencies {
                if (pAfter.configurations.findByName("shadowCommon")) {
                    shadowCommon(group: 'com.github.towdium', name: 'PinIn', version: "${verpinin}") {
                        transitive = false
                    }
                }
            }
        }

        if (type.notMain()) {
            pAfter.dependencies {
                compileOnly rootProject.project(":common-main")
                if (type.fabric) {
                    compileOnly rootProject.project(":fabric-main")
                }
                if (type.forge) {

                    if (!pAfter.path.contains("1.16.5")) {
                        compileOnly rootProject.project(":forge-main")
                    }
                }
            }
        }

        if (type.fabric || type.forge) {
            //source sets
            {
                def main = rootProject.project(":common-main")
                pAfter.compileJava {
                    source(main.sourceSets.main.allSource)
                }
                pAfter.sourcesJar {
                    from main.sourceSets.main.allJava
                }
                pAfter.processResources {
                    from main.sourceSets.main.resources
                }

                if (type.fabric) {
                    def fabricBase = rootProject.project(":fabric-main")
                    pAfter.compileJava {
                        source(fabricBase.sourceSets.main.allSource)
                    }
                    pAfter.sourcesJar {
                        from fabricBase.sourceSets.main.allJava
                    }
                    pAfter.processResources {
                        from fabricBase.sourceSets.main.resources
                    }
                }
                if (type.forge && !pAfter.path.contains("1.16.5")) {
                    def forgeBase = rootProject.project(":forge-main")
                    pAfter.compileJava {
                        source(forgeBase.sourceSets.main.allSource)
                    }
                    pAfter.sourcesJar {
                        from forgeBase.sourceSets.main.allJava
                    }
                    pAfter.processResources {
                        from forgeBase.sourceSets.main.resources
                    }
                }
            }

            pAfter.jar {
                archiveClassifier = "slim"
                manifest.attributes([
                        "Specification-Title"     : 'Just Enough Characters',
                        "Specification-Vendor"    : 'Towdium,vfyjxf_',
                        "Specification-Version"   : "${verspec}",
                        "Implementation-Title"    : rootProject.name,
                        "Implementation-Version"  : "${verspec}.${verbuild}",
                        "Implementation-Vendor"   : 'Towdium',
                        "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                        "Automatic-Module-Name"   : "jecharacters"
                ])
            }

        }
    }
}

subprojects { Project p ->
    def type = ProjectType.getType(p)
    if (!type.impl) return
    def targetsJson = p.file("build/resources/main/me/towdium/jecharacters/targets.json")

    p.tasks.register("generateTargetsJson") {
        def generalConfig = p.rootProject.file("generate.yaml")
        def versionConfig = p.parent.file("version_generate.yaml")
        def platformConfig = p.file("platform_generate.yaml")
        def mapping = p.rootProject.file("mapping.yaml")
        Yaml yaml = new Yaml()
        Map<String, Set<String>> all = new HashMap<>()
        Map<String, List<Map<String, String>>> mappings = yaml.load(mapping.text) as Map<String, List<Map<String, String>>>
        putAll(yaml, generalConfig, all)
        putAll(yaml, versionConfig, all)
        putAll(yaml, platformConfig, all)
        JsonObject json = new JsonObject()
        all.each { key, value ->
            JsonArray array = new JsonArray()
            for (target in value) {
                def remap = target
                mappings.entrySet().forEach {
                    if (target.contains(it.key)) {
                        if (type.fabric) {
                            remap = target.replace(it.key, getMapping("intermediary", it.value))
                        }
                        if (type.forge && p.path.contains("1.16.5")) {
                            remap = target.replace(it.key, getMapping("mcp", it.value))
                        }
                    }
                }
                if (type.fabric && containsForgeFluidStack(remap)) continue
                array.add(remap)
            }
            JsonObject inner = new JsonObject()
            inner.add("default", array)
            inner.add("additional", new JsonArray())
            json.add(key, inner)
        }
        json.add("removals", new JsonArray())
        json.add("suffixClassName", new JsonPrimitive(p.suffixClassName))
        String jsonStr = new GsonBuilder().setPrettyPrinting().create().toJson(json)
        if (!targetsJson.exists()) {
            targetsJson.parentFile.mkdirs()
            targetsJson.createNewFile()
        }
        targetsJson.write(jsonStr)
    }
    p.processResources {
        dependsOn "generateTargetsJson"
    }

}


static void putAll(Yaml yaml, File configFile, Map<String, List<String>> map) {
    if (!configFile.exists()) return
    Map<String, List<String>> list = yaml.load(configFile.text) as Map<String, List<String>>
    try {
        list.entrySet().each { entry ->
            def checked = entry.value.findAll { checkTargetFormat(it) }
            map.computeIfAbsent(entry.key, k -> new TreeSet<>()).addAll(checked)
        }
    } catch (Exception e) {
        throw new IllegalArgumentException("Invalid config from file: ${configFile.name}, ${e.message}")
    }

}

static boolean checkTargetFormat(String target) {
    String[] split = target.split(':')
    if (split.length != 2)
        throw new IllegalArgumentException("Invalid target: \"${target}\", must be in format 'namespace:name'")
    split.each { s ->
        if (s.contains(" "))
            throw new IllegalArgumentException("Invalid target: \"${target}\", spaces are not allowed")
    }
}

static boolean containsForgeFluidStack(String s) {
    return s.contains("Lnet/minecraftforge/fluids/FluidStack")
}

static String getMapping(String namespace, List<Map<String, String>> list) {
    return list.find { (it.keySet().contains(namespace)) }.get(namespace)
}


